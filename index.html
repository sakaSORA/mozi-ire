<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>文字入れ Pro (Stable & Crop)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&family=DotGothic16&family=Kaisei+Tokumin:wght@700&family=Kiwi+Maru:wght@500&family=M+PLUS+1p:wght@800&family=Sawarabi+Mincho&display=swap" rel="stylesheet">
    <style>
        :root { --panel-bg: #1c1c1e; --accent: #30d158; --safe-bottom: env(safe-area-inset-bottom); --tab-inactive: #3a3a3c; }
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; }
        html, body { height: 100%; margin: 0; padding: 0; background: #000; overflow: hidden; display: flex; flex-direction: column; color: white; font-family: sans-serif; position: fixed; width: 100%; }
        
        .preview-area { height: 65%; display: flex; align-items: center; justify-content: center; background: #000; overflow: hidden; touch-action: none; position: relative; }
        canvas { max-width: 100%; max-height: 100%; background: #111; object-fit: contain; }

        .controls-wrapper { height: 35%; background: var(--panel-bg); border-top: 1px solid #444; display: flex; flex-direction: column; padding-bottom: var(--safe-bottom); z-index: 10; }
        .save-row { padding: 8px 12px; border-bottom: 1px solid #333; display: flex; gap: 6px; flex-shrink: 0; }
        .file-label { flex: 1; background: #3a3a3c; color: #0a84ff; text-align: center; padding: 10px; border-radius: 10px; font-weight: bold; font-size: 11px; cursor: pointer; white-space: nowrap; }
        .save-btn { flex: 1.2; background: var(--accent); color: black; border: none; padding: 10px; border-radius: 10px; font-size: 11px; font-weight: bold; cursor: pointer; }

        .tab-header { display: flex; background: #000; padding: 4px 8px; gap: 4px; flex-shrink: 0; }
        .tab-btn { flex: 1; border: none; background: var(--tab-inactive); color: #8e8e93; padding: 12px 4px; font-size: 11px; font-weight: bold; border-radius: 8px; }
        .tab-btn.active { background: var(--panel-bg); color: white; }
        .tab-content { display: none; padding: 10px 14px; flex: 1; overflow-y: auto; }
        .tab-content.active { display: block; }

        #cropModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; flex-direction: column; }
        .crop-container { flex: 1; position: relative; overflow: hidden; }
        .crop-footer { padding: 20px; display: flex; gap: 10px; background: var(--panel-bg); padding-bottom: calc(20px + var(--safe-bottom)); }
        .crop-btn { flex: 1; padding: 15px; border-radius: 10px; border: none; font-weight: bold; font-size: 14px; }

        .layer-row { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
        .layer-list { flex: 1; display: flex; gap: 8px; overflow-x: auto; scrollbar-width: none; }
        .layer-item { background: #3a3a3c; padding: 8px 16px; border-radius: 12px; font-size: 12px; font-weight: bold; white-space: nowrap; border: 2px solid transparent; }
        .layer-item.selected { border-color: var(--accent); color: var(--accent); }
        .input-row { display: flex; gap: 8px; margin-bottom: 12px; }
        textarea { flex: 1; background: #2c2c2e; border: 1px solid #444; color: white; padding: 10px; border-radius: 10px; font-size: 16px; height: 44px; resize: none; }
        .font-select-mini { width: 90px; background: #2c2c2e; color: white; border: 1px solid #444; border-radius: 10px; font-size: 12px; font-weight: bold; }
        input[type="range"] { width: 100%; height: 36px; -webkit-appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { height: 8px; background: #444; border-radius: 4px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 26px; width: 26px; background: white; border-radius: 50%; border: 2px solid var(--accent); margin-top: -9px; }
        input[type="color"] { -webkit-appearance: none; width: 44px; height: 44px; border: 2px solid #444; background: none; border-radius: 50%; overflow: hidden; padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }
        .reset-btn-full { background: #444; color: white; border: none; padding: 14px; border-radius: 10px; font-size: 13px; width: 100%; margin-top: 8px; font-weight: bold; }
    </style>
</head>
<body>

    <div class="preview-area"><canvas id="canvas"></canvas></div>

    <div class="controls-wrapper">
        <div class="save-row">
            <label for="imageInput" class="file-label">画像読込</label>
            <input type="file" id="imageInput" accept="image/*" style="display:none;">
            <label for="fontInput" class="file-label">フォント追加</label>
            <input type="file" id="fontInput" accept=".ttf,.otf,.woff,.woff2" style="display:none;">
            <button id="downloadBtn" class="save-btn">画像保存</button>
        </div>

        <div class="tab-header">
            <button class="tab-btn active" onclick="openTab('tab-text')">文字・層</button>
            <button class="tab-btn" onclick="openTab('tab-style')">色・枠</button>
            <button class="tab-btn" onclick="openTab('tab-pos')">配置</button>
        </div>

        <div id="tab-text" class="tab-content active">
            <div class="layer-row">
                <button class="btn-action add-btn" style="background:#0a84ff; color:white; border:none; padding:10px; border-radius:10px;" id="addTextBtn">＋追加</button>
                <div class="layer-list" id="layerList"></div>
                <button class="btn-action del-btn" style="background:#ff3b30; color:white; border:none; padding:10px; border-radius:10px;" id="deleteTextBtn">削除</button>
            </div>
            <div class="input-row">
                <textarea id="textInput" placeholder="文字入力"></textarea>
                <button id="dirBtn" style="width:44px; background:#444; border:1px solid #666; border-radius:10px; color:white;">縦</button>
                <select id="fontSelect" class="font-select-mini"></select>
            </div>
        </div>

        <div id="tab-style" class="tab-content">
            <div style="display:flex; gap:12px; margin-bottom:14px;">
                <div style="flex:1; text-align:center;"><label style="font-size:10px; color:#888;">文字色</label><br><input type="color" id="colorPicker" value="#ffffff"></div>
                <div style="flex:1; text-align:center;"><label style="font-size:10px; color:#888;">縁色</label><br><input type="color" id="strokeColorPicker" value="#000000"></div>
                <div style="flex:1; text-align:center;"><label style="font-size:10px; color:#888;">背景色</label><br><input type="color" id="bgColorPicker" value="#000000"></div>
            </div>
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                <div><span style="font-size:10px;">縁太さ</span><input type="range" id="strokeWidthSlider" min="0" max="40" value="5"></div>
                <div><span style="font-size:10px;">背景不透明度</span><input type="range" id="bgAlphaSlider" min="0" max="100" value="0"></div>
            </div>
        </div>

        <div id="tab-pos" class="tab-content">
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:12px;">
                <div><span style="font-size:10px;">サイズ</span><input type="range" id="sizeSlider" min="10" max="800" value="100"></div>
                <div><span style="font-size:10px;">角度</span><input type="range" id="rotateSlider" min="0" max="360" value="0"></div>
            </div>
            <button id="resetBtn" class="reset-btn-full">位置・角度をリセット</button>
        </div>
    </div>

    <div id="cropModal">
        <div class="crop-container"><img id="cropImage"></div>
        <div class="crop-footer">
            <button class="crop-btn" style="background:#444; color:white;" id="cropCancel">キャンセル</button>
            <button class="crop-btn" style="background:var(--accent); color:black;" id="cropApply">切り取り決定</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

    <script>
        // 厳格な初期化管理
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const el = {
                imageInput: document.getElementById('imageInput'),
                fontInput: document.getElementById('fontInput'),
                textInput: document.getElementById('textInput'),
                fontSelect: document.getElementById('fontSelect'),
                colorPicker: document.getElementById('colorPicker'),
                strokeColorPicker: document.getElementById('strokeColorPicker'),
                bgColorPicker: document.getElementById('bgColorPicker'),
                bgAlphaSlider: document.getElementById('bgAlphaSlider'),
                strokeWidthSlider: document.getElementById('strokeWidthSlider'),
                sizeSlider: document.getElementById('sizeSlider'),
                rotateSlider: document.getElementById('rotateSlider'),
                resetBtn: document.getElementById('resetBtn'),
                downloadBtn: document.getElementById('downloadBtn'),
                dirBtn: document.getElementById('dirBtn'),
                addTextBtn: document.getElementById('addTextBtn'),
                deleteTextBtn: document.getElementById('deleteTextBtn'),
                cropCancel: document.getElementById('cropCancel'),
                cropApply: document.getElementById('cropApply')
            };

            let cropper = null, uploadedImage = null, texts = [], selectedIndex = 0, isDragging = false;

            function createText(val) { 
                return { text: val, x: canvas.width/2 || 400, y: canvas.height/2 || 400, fontSize: 100, fontFamily: "sans-serif", color: "#ffffff", strokeColor: "#000000", strokeWidth: 5, bgColor: "#000000", bgAlpha: 0, rotate: 0, isVertical: false }; 
            }

            // 画像読込 & クロップ起動
            el.imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = document.getElementById('cropImage');
                    img.src = ev.target.result;
                    document.getElementById('cropModal').style.display = 'flex';
                    if (cropper) cropper.destroy();
                    // Cropper.jsが読み込まれているか確認
                    if (typeof Cropper !== 'undefined') {
                        cropper = new Cropper(img, { viewMode: 1, dragMode: 'move', autoCropArea: 1 });
                    } else {
                        alert("ライブラリの読み込み待ちです。再度お試しください。");
                    }
                };
                reader.readAsDataURL(file);
            });

            el.cropCancel.onclick = () => { document.getElementById('cropModal').style.display = 'none'; el.imageInput.value = ''; };
            el.cropApply.onclick = () => {
                const croppedCanvas = cropper.getCroppedCanvas();
                uploadedImage = new Image();
                uploadedImage.onload = () => {
                    canvas.width = uploadedImage.width;
                    canvas.height = uploadedImage.height;
                    if (texts.length === 0) texts = [createText("画像編集")];
                    syncUIFromData(); draw();
                    document.getElementById('cropModal').style.display = 'none';
                };
                uploadedImage.src = croppedCanvas.toDataURL();
            };

            // フォント読込
            el.fontInput.addEventListener('change', async (e) => {
                const file = e.target.files[0]; if (!file) return;
                const name = "Font_" + Date.now();
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    const face = new FontFace(name, ev.target.result);
                    await face.load().then(loaded => {
                        document.fonts.add(loaded);
                        const opt = new Option("追加:"+file.name.substring(0,5), name);
                        el.fontSelect.add(opt);
                        el.fontSelect.value = name;
                        syncDataFromUI();
                    });
                };
                reader.readAsArrayBuffer(file);
            });

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!uploadedImage) {
                    canvas.width = 800; canvas.height = 800;
                    ctx.fillStyle="#111"; ctx.fillRect(0,0,800,800);
                    ctx.fillStyle="#666"; ctx.textAlign="center"; ctx.font="30px sans-serif";
                    ctx.fillText("画像を読み込んでください", 400, 400); return;
                }
                ctx.drawImage(uploadedImage, 0, 0);
                texts.forEach(t => {
                    ctx.save(); ctx.translate(t.x, t.y); ctx.rotate(t.rotate*Math.PI/180);
                    ctx.font = `bold ${t.fontSize}px ${t.fontFamily}`;
                    ctx.textAlign='center'; ctx.textBaseline='middle';
                    const lines = t.text.split('\n'), lh = t.fontSize*1.1;
                    if(t.bgAlpha > 0){
                        let bw, bh;
                        if(t.isVertical){ let mc=0; lines.forEach(l=>{if(l.length>mc)mc=l.length;}); bw=lines.length*lh; bh=mc*t.fontSize; }
                        else { let mw=0; lines.forEach(l=>{const w=ctx.measureText(l).width; if(w>mw)mw=w;}); bw=mw; bh=lines.length*lh; }
                        const r = parseInt(t.bgColor.slice(1,3),16), g = parseInt(t.bgColor.slice(3,5),16), b = parseInt(t.bgColor.slice(5,7),16);
                        ctx.fillStyle=`rgba(${r},${g},${b},${t.bgAlpha/100})`; ctx.fillRect(-bw/2-20,-bh/2-20,bw+40,bh+40);
                    }
                    lines.forEach((line, i) => {
                        const offset = (i - lines.length/2 + 0.5) * lh;
                        if(t.isVertical){
                            line.split('').forEach((char, j) => {
                                const y = (j - line.length/2 + 0.5) * t.fontSize;
                                let c = char, xo=0, yo=0;
                                if(char==='ー')c='丨'; if(["、","。"].includes(char)){ xo=t.fontSize*0.4; yo=-t.fontSize*0.4; }
                                if(t.strokeWidth>0){ ctx.lineJoin="round"; ctx.strokeStyle=t.strokeColor; ctx.lineWidth=t.strokeWidth; ctx.strokeText(c, xo, y+yo); }
                                ctx.fillStyle=t.color; ctx.fillText(c, xo, y+yo);
                            });
                        } else {
                            if(t.strokeWidth>0){ ctx.lineJoin="round"; ctx.strokeStyle=t.strokeColor; ctx.lineWidth=t.strokeWidth; ctx.strokeText(line, 0, offset); }
                            ctx.fillStyle=t.color; ctx.fillText(line, 0, offset);
                        }
                    });
                    ctx.restore();
                });
            }

            const syncDataFromUI = () => {
                const t = texts[selectedIndex]; if(!t)return;
                t.text=el.textInput.value; t.fontFamily=el.fontSelect.value; t.color=el.colorPicker.value;
                t.strokeColor=el.strokeColorPicker.value; t.bgColor=el.bgColorPicker.value;
                t.bgAlpha=parseInt(el.bgAlphaSlider.value); t.strokeWidth=parseInt(el.strokeWidthSlider.value);
                t.fontSize=parseInt(el.sizeSlider.value); t.rotate=parseInt(el.rotateSlider.value);
                updateLayerUI(); draw();
            };

            const syncUIFromData = () => {
                const t = texts[selectedIndex]; if(!t)return;
                el.textInput.value=t.text; el.fontSelect.value=t.fontFamily; el.colorPicker.value=t.color;
                el.strokeColorPicker.value=t.strokeColor; el.bgColorPicker.value=t.bgColor;
                el.bgAlphaSlider.value=t.bgAlpha; el.strokeWidthSlider.value=t.strokeWidth;
                el.sizeSlider.value=t.fontSize; el.rotateSlider.value=t.rotate;
                el.dirBtn.textContent=t.isVertical?"横":"縦"; updateLayerUI();
            };

            function updateLayerUI() {
                const list = document.getElementById('layerList');
                list.innerHTML='';
                texts.forEach((t,i)=>{
                    const it = document.createElement('div'); it.className=`layer-item ${i===selectedIndex?'selected':''}`;
                    it.textContent=t.text.substring(0,5)||"L"+(i+1); it.onclick=()=>{selectedIndex=i; syncUIFromData(); draw();};
                    list.appendChild(it);
                });
            }

            // イベント登録
            canvas.addEventListener('touchstart', () => isDragging = true, {passive:true});
            canvas.addEventListener('touchmove', (e) => {
                if(isDragging && texts[selectedIndex]){
                    const r = canvas.getBoundingClientRect();
                    const p = e.touches[0];
                    texts[selectedIndex].x = (p.clientX - r.left) * (canvas.width / r.width);
                    texts[selectedIndex].y = (p.clientY - r.top) * (canvas.height / r.height);
                    draw();
                }
            }, {passive:true});
            window.addEventListener('touchend', () => isDragging = false);

            ['textInput','fontSelect','colorPicker','strokeColorPicker','bgColorPicker','bgAlphaSlider','strokeWidthSlider','sizeSlider','rotateSlider'].forEach(id=>{
                el[id].addEventListener('input', syncDataFromUI);
            });

            el.addTextBtn.onclick=()=>{texts.push(createText("新規")); selectedIndex=texts.length-1; syncUIFromData(); draw();};
            el.deleteTextBtn.onclick=()=>{if(texts.length>1){texts.splice(selectedIndex,1); selectedIndex=0; syncUIFromData(); draw();}};
            el.dirBtn.onclick=()=>{texts[selectedIndex].isVertical=!texts[selectedIndex].isVertical; el.dirBtn.textContent=texts[selectedIndex].isVertical?"横":"縦"; draw();};
            el.resetBtn.onclick=()=>{texts[selectedIndex].x=canvas.width/2; texts[selectedIndex].y=canvas.height/2; texts[selectedIndex].rotate=0; draw();};
            el.downloadBtn.onclick=()=>{const l=document.createElement('a'); l.download=`photo_${Date.now()}.png`; l.href=canvas.toDataURL(); l.click();};

            // タブ切り替えグローバル関数化
            window.openTab = (id) => {
                document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
                document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                event.currentTarget.classList.add('active');
            };

            // 初期化
            const fonts = ["標準","特太","明朝","手書","レトロ","極太","ドット"];
            const values = ["sans-serif","'M PLUS 1p'","'Sawarabi Mincho'","'Kiwi Maru'","'Kaisei Tokumin'","'Dela Gothic One'","'DotGothic16'"];
            fonts.forEach((f,i)=>el.fontSelect.add(new Option(f,values[i])));
            texts = [createText("画像編集開始")]; updateLayerUI(); draw();
        });
    </script>
</body>
</html>
