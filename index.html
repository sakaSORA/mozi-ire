<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>文字入れツール Pro (PWA Ver.)</title>
    
    <link rel="manifest" href="./manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="./icon-512.png">
    <meta name="theme-color" content="#1c1c1e">

    <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&family=DotGothic16&family=Kaisei+Tokumin:wght@700&family=Kiwi+Maru:wght@500&family=M+PLUS+1p:wght@800&family=Sawarabi+Mincho&display=swap" rel="stylesheet">
    <style>
        :root { --panel-bg: #1c1c1e; --accent: #30d158; --safe-bottom: env(safe-area-inset-bottom); --tab-inactive: #3a3a3c; }
        * { -webkit-tap-highlight-color: transparent; box-sizing: border-box; touch-action: manipulation; }
        
        html, body { height: 100%; margin: 0; padding: 0; background: #000; overflow: hidden; display: flex; flex-direction: column; color: white; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; position: fixed; width: 100%; overscroll-behavior: none; }
        
        .preview-area { height: 40%; display: flex; align-items: center; justify-content: center; background: #000; overflow: hidden; touch-action: none; position: relative; border-bottom: 1px solid #333; }
        canvas { max-width: 100%; max-height: 100%; background: #111; object-fit: contain; box-shadow: 0 0 20px rgba(0,0,0,0.5); }

        .controls-wrapper { height: 60%; background: var(--panel-bg); display: flex; flex-direction: column; padding-bottom: var(--safe-bottom); z-index: 10; }
        
        .save-row { padding: 12px 16px; margin-bottom: 30px; display: flex; gap: 12px; flex-shrink: 0; }
        .file-label { flex: 1; background: #3a3a3c; color: #0a84ff; text-align: center; padding: 12px; border-radius: 10px; font-weight: bold; font-size: 13px; cursor: pointer; user-select: none; display: flex; align-items: center; justify-content: center; }
        .save-btn { flex: 1; background: var(--accent); color: black; border: none; padding: 12px; border-radius: 10px; font-size: 13px; font-weight: bold; cursor: pointer; }
        
        .tab-header { display: flex; background: #000; padding: 6px 10px; gap: 6px; flex-shrink: 0; }
        .tab-btn { flex: 1; border: none; background: var(--tab-inactive); color: #8e8e93; padding: 14px 4px; font-size: 12px; font-weight: bold; border-radius: 8px; cursor: pointer; }
        .tab-btn.active { background: var(--panel-bg); color: white; }

        .tab-content { display: none; padding: 16px 16px; flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; }
        .tab-content.active { display: block; }

        .layer-row { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        .layer-list { flex: 1; display: flex; gap: 8px; overflow-x: auto; scrollbar-width: none; }
        .layer-item { background: #3a3a3c; padding: 8px 14px; border-radius: 10px; font-size: 12px; font-weight: bold; white-space: nowrap; border: 2px solid transparent; cursor: pointer; }
        .layer-item.selected { border-color: var(--accent); background: #2c2c2e; color: var(--accent); }

        .input-row { display: flex; gap: 8px; margin-bottom: 20px; align-items: stretch; }
        textarea { flex: 1; background: #2c2c2e; border: 1px solid #444; color: white; padding: 10px; border-radius: 10px; font-size: 16px; height: 48px; resize: none; }
        .dir-btn { width: 48px; background: #444; color: white; border: 1px solid #666; border-radius: 10px; font-size: 13px; font-weight: bold; }
        .dir-btn.active { background: #0a84ff; border-color: #0a84ff; }
        
        .slider-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        .slider-row { display: flex; flex-direction: column; gap: 6px; font-size: 11px; color: #aaa; }
        input[type="range"] { width: 100%; height: 36px; -webkit-appearance: none; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { height: 8px; background: #444; border-radius: 4px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; height: 26px; width: 26px; background: white; border-radius: 50%; border: 2px solid var(--accent); margin-top: -9px; }

        .btn-action { border: none; padding: 10px 16px; border-radius: 10px; font-size: 12px; font-weight: bold; }
        .add-btn { background: #0a84ff; color: white; }
        .del-btn { background: #ff3b30; color: white; }

        .color-row { display: flex; gap: 12px; margin-bottom: 16px; }
        .color-item { display: flex; flex-direction: column; align-items: center; flex: 1; gap: 6px; font-size: 11px; position: relative; }
        .color-item.active::after { content: '●'; position: absolute; bottom: -12px; color: var(--accent); font-size: 8px; }
        
        input[type="color"] { -webkit-appearance: none; width: 48px; height: 48px; border: 2px solid #444; background: none; border-radius: 50%; padding: 0; cursor: pointer; }
        
        .palette-wrapper { background: #2c2c2e; padding: 10px 14px; border-radius: 12px; margin-bottom: 20px; display: flex; align-items: center; justify-content: space-between; }
        .palette-label { font-size: 11px; color: #888; margin-right: 12px; line-height: 1.2; }
        .palette-colors { display: flex; gap: 10px; }
        .swatch { width: 36px; height: 36px; border-radius: 50%; border: 2px solid #555; cursor: pointer; transition: transform 0.1s, border-color 0.2s; position: relative; }
        .swatch:active { transform: scale(0.9); }
        .swatch.saved-anim { animation: flash 0.4s ease-out; border-color: white; }
        @keyframes flash { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255,255,255,0.7); } 50% { transform: scale(1.2); box-shadow: 0 0 0 6px rgba(255,255,255,0); } 100% { transform: scale(1); } }
        
        .reset-btn-full { background: #444; color: white; border: none; padding: 14px; border-radius: 10px; font-size: 13px; width: 100%; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>
    <div class="preview-area"><canvas id="canvas"></canvas></div>

    <div class="controls-wrapper">
        <div class="save-row">
            <label for="imageInput" class="file-label">画像読込</label>
            <input type="file" id="imageInput" accept="image/*" style="display:none;">
            <button type="button" id="downloadBtn" class="save-btn">画像保存</button>
        </div>

        <div class="tab-header">
            <button type="button" class="tab-btn active" id="btn-tab-text">文字・層</button>
            <button type="button" class="tab-btn" id="btn-tab-style">色・枠</button>
            <button type="button" class="tab-btn" id="btn-tab-pos">配置</button>
        </div>

        <div id="tab-text" class="tab-content active">
            <div class="layer-row">
                <button type="button" class="btn-action add-btn" id="addTextBtn">＋追加</button>
                <div class="layer-list" id="layerList"></div>
                <button type="button" class="btn-action del-btn" id="deleteTextBtn">削除</button>
            </div>
            <div class="input-row">
                <textarea id="textInput" placeholder="文字入力"></textarea>
                <button type="button" id="dirBtn" class="dir-btn">縦</button>
                <select id="fontSelect" style="width:90px; background:#2c2c2e; color:white; border-radius:10px; font-size:12px;">
                    <option value="sans-serif">標準</option>
                    <option value="'M PLUS 1p', sans-serif">特太</option>
                    <option value="'Sawarabi Mincho', serif">明朝</option>
                    <option value="'Kiwi Maru', serif">手書</option>
                    <option value="'Kaisei Tokumin', serif">レトロ</option>
                    <option value="'Dela Gothic One', cursive">極太</option>
                    <option value="'DotGothic16', sans-serif">ドット</option>
                </select>
            </div>
        </div>

        <div id="tab-style" class="tab-content">
            <div class="color-row">
                <div class="color-item active" id="wrap-color"><label>文字色</label><input type="color" id="colorPicker"></div>
                <div class="color-item" id="wrap-stroke"><label>縁色</label><input type="color" id="strokeColorPicker"></div>
                <div class="color-item" id="wrap-bg"><label>背景色</label><input type="color" id="bgColorPicker"></div>
            </div>
            
            <div class="palette-wrapper">
                <div class="palette-label">お気に入り<br><span style="font-size:9px; opacity:0.7;">長押しで保存</span></div>
                <div class="palette-colors" id="paletteContainer"></div>
            </div>

            <div class="slider-grid">
                <div class="slider-row"><span>縁の太さ</span><input type="range" id="strokeWidthSlider" min="0" max="200"></div>
                <div class="slider-row"><span>背景不透明度</span><input type="range" id="bgAlphaSlider" min="0" max="100"></div>
            </div>
        </div>

        <div id="tab-pos" class="tab-content">
            <div class="slider-grid">
                <div class="slider-row"><span>サイズ</span><input type="range" id="sizeSlider" min="10" max="800"></div>
                <div class="slider-row"><span>角度</span><input type="range" id="rotateSlider" min="0" max="360"></div>
            </div>
            <button type="button" id="resetBtn" class="reset-btn-full">位置・角度をリセット</button>
        </div>
    </div>
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(err => console.log(err));
            });
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const el = {
            imageInput: document.getElementById('imageInput'),
            textInput: document.getElementById('textInput'),
            fontSelect: document.getElementById('fontSelect'),
            colorPicker: document.getElementById('colorPicker'),
            strokeColorPicker: document.getElementById('strokeColorPicker'),
            bgColorPicker: document.getElementById('bgColorPicker'),
            bgAlphaSlider: document.getElementById('bgAlphaSlider'),
            strokeWidthSlider: document.getElementById('strokeWidthSlider'),
            sizeSlider: document.getElementById('sizeSlider'),
            rotateSlider: document.getElementById('rotateSlider'),
            resetBtn: document.getElementById('resetBtn'),
            downloadBtn: document.getElementById('downloadBtn'),
            dirBtn: document.getElementById('dirBtn'),
            addTextBtn: document.getElementById('addTextBtn'),
            deleteTextBtn: document.getElementById('deleteTextBtn'),
            layerList: document.getElementById('layerList'),
            paletteContainer: document.getElementById('paletteContainer'),
            tabs: { text: document.getElementById('btn-tab-text'), style: document.getElementById('btn-tab-style'), pos: document.getElementById('btn-tab-pos') },
            contents: { text: document.getElementById('tab-text'), style: document.getElementById('tab-style'), pos: document.getElementById('tab-pos') }
        };

        let state = { 
            imageObj: null, texts: [], selectedIndex: 0, 
            isDragging: false, dragOffset: { x: 0, y: 0 },
            activePickerId: 'colorPicker',
            favorites: JSON.parse(localStorage.getItem('myPwaColors')) || ['#FF0000', '#30D158', '#0A84FF']
        };

        function createText(val = "テキスト") {
            return {
                text: val, x: canvas.width / 2, y: canvas.height / 2,
                fontSize: 80, fontFamily: "sans-serif", color: "#ffffff",
                strokeColor: "#000000", strokeWidth: 10, bgColor: "#000000",
                bgAlpha: 0, rotate: 0, isVertical: false
            };
        }

        function initPalette() {
            el.paletteContainer.innerHTML = '';
            state.favorites.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = 'swatch';
                swatch.style.backgroundColor = color;
                swatch.onclick = () => {
                    const picker = document.getElementById(state.activePickerId);
                    picker.value = color;
                    picker.dispatchEvent(new Event('input'));
                };
                let timer;
                const start = () => timer = setTimeout(() => {
                    const colorValue = document.getElementById(state.activePickerId).value;
                    state.favorites[index] = colorValue;
                    localStorage.setItem('myPwaColors', JSON.stringify(state.favorites));
                    initPalette();
                }, 600);
                const end = () => clearTimeout(timer);
                swatch.addEventListener('mousedown', start);
                swatch.addEventListener('touchstart', start, {passive:false});
                swatch.addEventListener('mouseup', end);
                swatch.addEventListener('touchend', end);
                el.paletteContainer.appendChild(swatch);
            });
        }
        
        const setActivePicker = (id) => {
            state.activePickerId = id;
            ['wrap-color', 'wrap-stroke', 'wrap-bg'].forEach(wid => document.getElementById(wid).classList.remove('active'));
            if(id==='colorPicker') document.getElementById('wrap-color').classList.add('active');
            if(id==='strokeColorPicker') document.getElementById('wrap-stroke').classList.add('active');
            if(id==='bgColorPicker') document.getElementById('wrap-bg').classList.add('active');
        };

        const syncDataFromUI = () => {
            const t = state.texts[state.selectedIndex]; if (!t) return;
            t.text = el.textInput.value; t.fontFamily = el.fontSelect.value;
            t.color = el.colorPicker.value; t.strokeColor = el.strokeColorPicker.value;
            t.bgColor = el.bgColorPicker.value; t.bgAlpha = parseInt(el.bgAlphaSlider.value);
            t.strokeWidth = parseInt(el.strokeWidthSlider.value); t.fontSize = parseInt(el.sizeSlider.value);
            t.rotate = parseInt(el.rotateSlider.value);
            updateLayerUI(); draw();
        };

        const syncUIFromData = () => {
            const t = state.texts[state.selectedIndex]; if (!t) return;
            el.textInput.value = t.text; el.fontSelect.value = t.fontFamily;
            el.colorPicker.value = t.color; el.strokeColorPicker.value = t.strokeColor;
            el.bgColorPicker.value = t.bgColor; el.bgAlphaSlider.value = t.bgAlpha;
            el.strokeWidthSlider.value = t.strokeWidth; el.sizeSlider.value = t.fontSize;
            el.rotateSlider.value = t.rotate;
            el.dirBtn.innerText = t.isVertical ? "横" : "縦";
            updateLayerUI();
        };

        function updateLayerUI() {
            el.layerList.innerHTML = '';
            state.texts.forEach((t, i) => {
                const item = document.createElement('div');
                item.className = `layer-item ${i === state.selectedIndex ? 'selected' : ''}`;
                item.innerText = t.text.substring(0, 5) || "層" + (i+1);
                item.onclick = () => { state.selectedIndex = i; syncUIFromData(); draw(); };
                el.layerList.appendChild(item);
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!state.imageObj) {
                ctx.fillStyle = "#111"; ctx.fillRect(0,0, canvas.width, canvas.height);
                ctx.fillStyle = "#666"; ctx.font = "30px sans-serif"; ctx.textAlign = "center";
                ctx.fillText("画像を読み込んでください", canvas.width/2, canvas.height/2);
            } else {
                ctx.drawImage(state.imageObj, 0, 0);
            }
            state.texts.forEach(t => {
                ctx.save();
                ctx.translate(t.x, t.y); ctx.rotate(t.rotate * Math.PI / 180);
                ctx.font = `bold ${t.fontSize}px ${t.fontFamily}`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                const lines = t.text.split('\n');
                const lh = t.fontSize * 1.1;

                // 1. まず背景ボックスを描く（一番下）
                if (t.bgAlpha > 0) {
                    ctx.fillStyle = t.bgColor + Math.round(t.bgAlpha * 2.55).toString(16).padStart(2, '0');
                    let maxW = 0; lines.forEach(l => { const m = ctx.measureText(l); if(m.width > maxW) maxW = m.width; });
                    const pad = t.fontSize * 0.2;
                    ctx.fillRect(-(maxW+pad*2)/2, -lh/2, maxW+pad*2, lh * lines.length); 
                }

                // 文字の描画ループ
                lines.forEach((line, i) => {
                    const offset = (i - lines.length / 2 + 0.5) * lh;
                    
                    // 2. 縁取りを描く（背景の上、塗りの下）
                    if (t.strokeWidth > 0) {
                        ctx.strokeStyle = t.strokeColor;
                        ctx.lineWidth = t.strokeWidth;
                        ctx.lineJoin = "round";
                        ctx.strokeText(line, 0, offset);
                    }
                    
                    // 3. 塗りを描く（一番上）
                    ctx.fillStyle = t.color;
                    ctx.fillText(line, 0, offset);
                });
                ctx.restore();
            });
        }

        const getPos = (x, y) => {
            const r = canvas.getBoundingClientRect();
            return { x: (x - r.left) * (canvas.width / (r.width || 1)), y: (y - r.top) * (canvas.height / (r.height || 1)) };
        };

        const handleStart = (x, y) => {
            const p = getPos(x, y);
            for (let i = state.texts.length - 1; i >= 0; i--) {
                const t = state.texts[i];
                if (Math.sqrt((p.x - t.x)**2 + (p.y - t.y)**2) < Math.max(50, t.fontSize)) {
                    state.isDragging = true; state.selectedIndex = i;
                    state.dragOffset = { x: t.x - p.x, y: t.y - p.y };
                    syncUIFromData(); draw(); return;
                }
            }
        };

        canvas.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
        window.addEventListener('mousemove', e => { if (state.isDragging) { const p = getPos(e.clientX, e.clientY); state.texts[state.selectedIndex].x = p.x + state.dragOffset.x; state.texts[state.selectedIndex].y = p.y + state.dragOffset.y; draw(); } });
        window.addEventListener('mouseup', () => state.isDragging = false);
        canvas.addEventListener('touchstart', e => { e.preventDefault(); handleStart(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
        window.addEventListener('touchmove', e => { if (state.isDragging) { e.preventDefault(); const p = getPos(e.touches[0].clientX, e.touches[0].clientY); state.texts[state.selectedIndex].x = p.x + state.dragOffset.x; state.texts[state.selectedIndex].y = p.y + state.dragOffset.y; draw(); } }, { passive: false });
        window.addEventListener('touchend', () => state.isDragging = false);

        el.imageInput.onchange = (e) => {
            const file = e.target.files[0]; if (!file) return;
            const img = new Image();
            img.onload = () => {
                state.imageObj = img; canvas.width = img.width; canvas.height = img.height;
                state.texts.forEach(t => { t.x = img.width/2; t.y = img.height/2; });
                if (state.texts.length === 0) state.texts.push(createText("編集開始"));
                syncUIFromData(); draw();
            };
            img.src = URL.createObjectURL(file); e.target.value = '';
        };

        ['colorPicker', 'strokeColorPicker', 'bgColorPicker'].forEach(id => {
            const p = document.getElementById(id);
            p.addEventListener('click', () => setActivePicker(id));
            p.addEventListener('input', syncDataFromUI);
        });

        const switchTab = (n) => {
            Object.keys(el.tabs).forEach(k => { el.tabs[k].classList.remove('active'); el.contents[k].classList.remove('active'); });
            el.tabs[n].classList.add('active'); el.contents[n].classList.add('active');
        };
        el.tabs.text.onclick = () => switchTab('text');
        el.tabs.style.onclick = () => switchTab('style');
        el.tabs.pos.onclick = () => switchTab('pos');

        el.addTextBtn.onclick = () => { state.texts.push(createText("新規")); state.selectedIndex = state.texts.length - 1; syncUIFromData(); draw(); };
        el.deleteTextBtn.onclick = () => { state.texts.splice(state.selectedIndex, 1); if(state.texts.length > 0) state.selectedIndex = 0; syncUIFromData(); draw(); };
        el.downloadBtn.onclick = () => { const a = document.createElement('a'); a.download = 'edit.png'; a.href = canvas.toDataURL(); a.click(); };
        el.resetBtn.onclick = () => { const t = state.texts[state.selectedIndex]; if(t){ t.x = canvas.width/2; t.y = canvas.height/2; t.rotate = 0; syncUIFromData(); draw(); } };
        el.dirBtn.onclick = () => { const t = state.texts[state.selectedIndex]; if(t){ t.isVertical = !t.isVertical; syncUIFromData(); } };

        ['textInput', 'fontSelect', 'bgAlphaSlider', 'strokeWidthSlider', 'sizeSlider', 'rotateSlider'].forEach(id => el[id].addEventListener('input', syncDataFromUI));

        document.fonts.ready.then(() => { 
            canvas.width = 800; canvas.height = 800;
            state.texts.push(createText("PWA Mode")); 
            updateLayerUI(); initPalette(); setActivePicker('colorPicker'); draw(); 
        });
    </script>
</body>
</html>
